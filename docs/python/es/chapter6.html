
<html>
<head>

<title>Karel Lector</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/> 
<script src="//compedu.stanford.edu/codeInternational/docs/plugins/jquery.min.js"></script>
<link href="//compedu.stanford.edu/codeInternational/docs/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/> 
<script src="//compedu.stanford.edu/codeInternational/docs/plugins/bootstrap/js/bootstrap.min.js"></script>
<link href="//compedu.stanford.edu/codeInternational/docs/style.css" rel="stylesheet"/> 
<script src="//compedu.stanford.edu/codeInternational/docs//karel/js/html/websiteImports.js"></script>
<script>importCss();</script>
<script>importJs();</script>
</head>
<body>
<!-- container -->
<div class="bookContainer">

<!-- side bar -->
<div class="bookSideBar">
<div class="homeLink">
 <a href="//compedu.stanford.edu/codeInternational/docs/python/es/intro.html">
<span aria-hidden="true" class="glyphicon glyphicon-home"></span> Karel</a> 
</div>
<hr/>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter1.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter1.html">1 - Conoce Karel</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter2.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter2.html">2 - Programación</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter3.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter3.html">3 - Nuevas funciones</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter4.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter4.html">4 - Descomposición</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter5.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter5.html">5 - Ciclos For</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter6.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter6.html">6 - Ciclos While</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter7.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter7.html">7 - Condicionales</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter8.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter8.html">8 - Refinamiento</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/chapter9.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/chapter9.html">9 - Funciones adicionales</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/reference.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/reference.html">10 - Referencia</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeInternational/docs/python/es/ide.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeInternational/docs/python/es/ide.html">11 - Código</a> 
</div>
<hr/>
<!-- <a href="//compedu.stanford.edu/codeInternational/docs/"><img style = "width:40px" src="//compedu.stanford.edu/codeInternational/docs/images/unFlag.png"/>  Learn more</a>  -->
<!-- <center>
    <img style ="width:75px;" src="//compedu.stanford.edu/codeInternational/docs/images/stanford.png"/> 
    </center> -->
</div>
<!-- content -->
<div class="bookContent" style="display: flex;">
<!-- right gutter -->
<div style="flex-grow:1;max-width:50px;"></div>
<!-- main stuff -->
<div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px">
<div class="row">
<div class="col-md-12 col-xs-12">


<h1>Capítulo 6: Ciclos While</h1>
<hr/>
<p>La técnica de definir nuevas funciones y definir <code>for</code> ciclo s, tan útiles como son, en realidad no permite a Karel resolver ningún problema nuevo. Cada vez que run un programa, siempre hace exactamente lo mismo. Los programas se vuelven mucho más útiles cuando pueden responder de manera diferente a diferentes entradas.</p>
<p>Como ejemplo, digamos que desea escribir un programa para tener Karel moverse en una pared. Pero no desea simplemente que este programa funcione en un mundo con un tamaño fijo. Le gustaría escribir un programa único que pudiera funcionar en cualquier mundo.</p>





<div class="section embeddedIde" id="moveToWall">
<div class="ide getStarted" id="moveToWallIde" style="height:316.8px">
<div class="ideCenter" id="moveToWallIdeCenter">
<div class="ideEditorDiv" id="moveToWallEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="moveToWallCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Cambiar mundo<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="moveToWallWorlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="moveToWallCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="moveToWallRunButton"><span class="glyphicon glyphicon-play"></span>Ejecute el programa</button>
</div>
</div>
<script>

        

function examplemoveToWall() {
STARTER_CODE = `

# Archivo: MoveToWall.py
# ------------------------------
# Utiliza un "while" ciclo a moverse Karel hasta que llega
# una pared. Funciona en mundos de cualquier tamaño.
from karel.stanfordkarel import *

# el programa comienza con main
def main():
   # llamar al moverse a la función de pared
   moverse_a_la_pared()

# esta es una función muy útil
def moverse_a_la_pared():
   # repite el cuerpo mientras la condición se mantiene
   while frente_despejado():
      moverse()



`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importPythonEditor('moveToWallEditor','moveToWallEditorDiv', STARTER_CODE, false);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('moveToWallCanvas');
    karelIde = KarelIde('python',karelEditor, canvas, '7x7', 0.0, 'es');
    $('#moveToWallRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('moveToWallWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#moveToWallRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#moveToWallRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 316.8;
    var canvasWidth = 300
    var parentWidth = $("#moveToWall").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('moveToWallIde');
    var editorDiv = document.getElementById('moveToWallEditorDiv');
    var canvas = document.getElementById('moveToWallCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplemoveToWall();
    </script>
</div>

<p>Intente cambiar el mundo haciendo clic en el menú desplegable "Cambiar mundo" sobre el mundo. Para cualquier tamaño de mundo, Karel será moverse hasta que golpee una pared. Tenga en cuenta que esta hazaña no se puede lograr utilizando un <code class="keyword">for</code> ciclo . Eso requeriría que conozcamos el tamaño del mundo al momento de programar.</p>
<h3>Basic While Loop</h3>
<p>En Karel , un <code class="keyword">while</code> ciclo se usa para repetir un cuerpo de código<i>Mientras</i>se cumple una condición dada. los <code>while</code> ciclo tiene la siguiente forma general:</p>
<p class="demoCode">
 <code><span class="keyword">while</span> </code> <i class="demoText">prueba</i> <code>:</code> <br/>
<i class="demoText" style="margin-left:2em">declaraciones a repetir</i><br/>
</p>
<p>El control de flujo de un <code>while</code> ciclo es el siguiente. Cuando el programa alcanza un <code>while</code> ciclo comienza a repetir un proceso donde primero<i>cheques</i>Si la prueba pasa, y si es así.<i>run s</i>el código en el cuerpo.</p>Cuando el programa<i>cheques</i>Si la prueba pasa, decide si el<i class="demoText">prueba</i>es cierto para el estado actual del mundo. Si es así, ciclo será run el código en el cuerpo. Si la prueba falla, el ciclo ha terminado y el programa moverse está encendido.
<p>Cuando el programa<i>run s</i>el cuerpo del ciclo , el programa ejecuta las líneas en el cuerpo de una en una. Cuando el programa llega al final del <code>while</code> ciclo , vuelve a la parte superior del ciclo . Luego, vuelve a verificar la prueba y continúa hasta ciclo si pasa. El programa no sale del ciclo hasta que llega a una verificación y la prueba falla.</p>
<p>Karel tiene muchos<i class="demoText">prueba</i>declaraciones, y vamos a repasar todos ellos en el siguiente capítulo. Por ahora vamos a utilizar una sola declaración de prueba: <code>frente_despejado()</code> lo cual es cierto si no hay una pared directamente enfrente de Karel .</p>
<h3>Fencepost Bug</h3>
<p>Modifiquemos nuestro programa anterior para hacerlo más interesante. En lugar de simplemente moverse hacia una pared, Karel que Karel coloque una línea de conos , una en cada cuadrado. Nuevamente queremos que este programa funcione para un mundo de cualquier tamaño:</p>





<div class="section embeddedIde" id="beeperLineBug1">
<div class="ide getStarted" id="beeperLineBug1Ide" style="height:299.20000000000005px">
<div class="ideCenter" id="beeperLineBug1IdeCenter">
<div class="ideEditorDiv" id="beeperLineBug1EditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineBug1CanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Cambiar mundo<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineBug1Worlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineBug1Canvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineBug1RunButton"><span class="glyphicon glyphicon-play"></span>Ejecute el programa</button>
</div>
</div>
<script>

        

function examplebeeperLineBug1() {
STARTER_CODE = `

# Archivo: Cono LineBug.py
# ------------------------------
# Utiliza ciclo while para colocar una línea de conos .
# Este programa funciona para un mundo de cualquier tamaño.
# Sin embargo, porque cada mundo requiere uno menos
# moverse s que put_ conos siempre falta un cono .
from karel.stanfordkarel import *

# el programa comienza en main
def main():
   # se repite hasta que karel enfrenta a una pared
   while frente_despejado():
      # colocar un cono en el cuadrado actual
      poner_cono()
      # moverse al siguiente cuadrado
      moverse()


`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importPythonEditor('beeperLineBug1Editor','beeperLineBug1EditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineBug1Canvas');
    karelIde = KarelIde('python',karelEditor, canvas, '7x7', 0.0, 'es');
    $('#beeperLineBug1RunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineBug1Worlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineBug1RunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineBug1RunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 299.20000000000005;
    var canvasWidth = 300
    var parentWidth = $("#beeperLineBug1").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineBug1Ide');
    var editorDiv = document.getElementById('beeperLineBug1EditorDiv');
    var canvas = document.getElementById('beeperLineBug1CanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLineBug1();
    </script>
</div>

<p>Eso se ve genial. Excepto por un problema. En todos los mundos, Karel no coloca cono en el último cuadrado de la línea (mire de cerca). Cuando Karel está en el último cuadrado, el programa no ejecuta el cuerpo del ciclo porque la prueba ya no pasa: Karel está frente a una pared. Es posible que tenga la tentación de intentar cambiar el orden del cuerpo para que Karel moverse s antes de colocar un cono . El código es editable, así que pruébalo.</p>
<p>Existe un problema más profundo que ningún reordenamiento del cuerpo puede resolver. Para el mundo con 7 columnas, Karel necesita poner 7 conos , pero solo debería <code>moverse()</code> 6 veces. Desde el <code>while</code> ciclo ejecuta ambas líneas cuando pasa una prueba, ¿cómo puede hacer que el programa ejecute un comando una vez más que el otro?</p>
<p>El error en este programa es un ejemplo de un problema de programación llamado <b>error del poste</b> . El nombre proviene del hecho de que si desea construir una cerca hecha de paneles que tengan un poste de cerca en cualquier tamaño, el número de postes de cerca es siempre uno mayor que el número de paneles. ¿Cuántos postes de cerca, por ejemplo, necesita para construir una cerca con 10 paneles? La respuesta es 11, como se ilustra en el siguiente diagrama:</p>
<center>
<img src="//compedu.stanford.edu/codeInternational/docs/images/ch6/fencepost.png" style="width:500px;margin-bottom:10px"/> 
</center>
<p>Una vez que lo descubra, corregir este error es bastante fácil. Antes de que Karel detenga en el fin del mundo, todo lo que tiene que hacer el programa es colocar un cono final:</p>





<div class="section embeddedIde" id="beeperLine">
<div class="ide getStarted" id="beeperLineIde" style="height:334.40000000000003px">
<div class="ideCenter" id="beeperLineIdeCenter">
<div class="ideEditorDiv" id="beeperLineEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Cambiar mundo<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineWorlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineRunButton"><span class="glyphicon glyphicon-play"></span>Ejecute el programa</button>
</div>
</div>
<script>

        

function examplebeeperLine() {
STARTER_CODE = `


# Archivo: ConoLínea.py
# ------------------------------
# Utiliza ciclo while para colocar una línea de conos .
# Este programa funciona para un mundo de cualquier tamaño.
from karel.stanfordkarel import *

# el programa comienza en main
def main():
   # se repite hasta que karel enfrenta a una pared
   while frente_despejado():
      # colocar un cono en el cuadrado actual
      poner_cono()
      # moverse al siguiente cuadrado
      moverse()
   # resuelve el error del poste de la cerca
   poner_cono()



`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importPythonEditor('beeperLineEditor','beeperLineEditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineCanvas');
    karelIde = KarelIde('python',karelEditor, canvas, '7x7', 0.8, 'es');
    $('#beeperLineRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 334.40000000000003;
    var canvasWidth = 300
    var parentWidth = $("#beeperLine").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineIde');
    var editorDiv = document.getElementById('beeperLineEditorDiv');
    var canvas = document.getElementById('beeperLineCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLine();
    </script>
</div>
<hr/>
<center>
<a class="btn btn-primary btn-lg" href="chapter7.html" role="button">Siguiente capítulo</a> 
</center>




<div style="height:60px"></div>
</div>
</div>
</div>
<!-- right gutter -->
<div style="flex-grow:4"></div>
</div>
</div>
</body>
</html>
