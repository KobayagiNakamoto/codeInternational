
<html>
<head>

<title>Karel Reader</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/> 
<script src="//compedu.stanford.edu/codeinternational/docsplugins/jquery.min.js"></script>
<link href="//compedu.stanford.edu/codeinternational/docsplugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/> 
<script src="//compedu.stanford.edu/codeinternational/docsplugins/bootstrap/js/bootstrap.min.js"></script>
<link href="//compedu.stanford.edu/codeinternational/docsstyle.css" rel="stylesheet"/> 
<script src="//compedu.stanford.edu/codeinternational/docs/karel/js/html/websiteImports.js"></script>
<script>importCss();</script>
<script>importJs();</script>
</head>
<body>
<!-- container -->
<div class="bookContainer">

<!-- side bar -->
<div class="bookSideBar">
<div class="homeLink">
 <a href="//compedu.stanford.edu/codeinternational/docspython/fr/intro.html">
<span aria-hidden="true" class="glyphicon glyphicon-home"></span> 
      Karel
    </a> 
</div>
<hr/>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter1.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter1.html">
      1 - Rencontrez Karel
    </a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter2.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter2.html">2 - Programmation</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter3.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter3.html">3 - Nouvelles fonctions</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter4.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter4.html">4 - Décomposition</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter5.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter5.html">5 - Boucles For</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter6.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter6.html">6 - Boucles While</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter7.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter7.html">7 - Conditions</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter8.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter8.html">8 - Raffinement</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/chapter9.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/chapter9.html">9 - Fonctionnalités supplémentaires</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/reference.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/reference.html">10 - Référence</a> 
</div>
<div class="chapterTab" onclick="location.href='//compedu.stanford.edu/codeinternational/docspython/fr/ide.html'">
<a class="bookLink btn btn-link" href="//compedu.stanford.edu/codeinternational/docspython/fr/ide.html">11 - Code</a> 
</div>
<hr/>
<!-- <a href="//compedu.stanford.edu/codeinternational/docs"><img style = "width:40px" src="//compedu.stanford.edu/codeinternational/docsimages/unFlag.png"/>  Learn more</a>  -->
<!-- <center>
    <img style ="width:75px;" src="//compedu.stanford.edu/codeinternational/docsimages/stanford.png"/> 
    </center> -->
</div>
<!-- content -->
<div class="bookContent" style="display: flex;">
<!-- right gutter -->
<div style="flex-grow:1;max-width:50px;"></div>
<!-- main stuff -->
<div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px">
<div class="row">
<div class="col-md-12 col-xs-12">


<h1>Chapitre 6: Boucles While</h1>
<hr/>
<p>La technique de définition de nouvelles fonctions et de définition <code>for</code> les boucles - aussi utiles soient-elles - ne permettent pas réellement à Karel de résoudre de nouveaux problèmes. Chaque fois que vous run un programme, il fait toujours exactement la même chose. Les programmes deviennent beaucoup plus utiles lorsqu'ils peuvent répondre différemment à différentes entrées.</p>
<p>À titre d'exemple, disons que vous vouliez écrire un programme pour avoir Karel avancer sur un mur. Mais vous ne voulez pas simplement que ce programme fonctionne sur un seul monde avec une taille fixe. Vous souhaitez écrire un programme unique qui pourrait fonctionner sur n'importe quel monde.</p>





<div class="section embeddedIde" id="moveToWall">
<div class="ide getStarted" id="moveToWallIde" style="height:316.8px">
<div class="ideCenter" id="moveToWallIdeCenter">
<div class="ideEditorDiv" id="moveToWallEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="moveToWallCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Changer le monde<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="moveToWallWorlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="moveToWallCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="moveToWallRunButton"><span class="glyphicon glyphicon-play"></span>Exécuter de programme</button>
</div>
</div>
<script>

        

function examplemoveToWall() {
STARTER_CODE = `

# Fichier: MoveToWall.py
# ------------------------------
# Utilise une boucle «while» vers avancer Karel jusqu'à ce qu'elle avancer
# un mur. Fonctionne sur n'importe quel monde de taille.
from karel.stanfordkarel import *

# le programme commence par main
def main():
   # appeler la fonction avancer au mur
   avancer_au_mur()

# c'est une fonction très utile
def avancer_au_mur():
   # répéter le corps tant que la condition est maintenue
   while l'avant_est_clair():
      avancer()



`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importPythonEditor('moveToWallEditor','moveToWallEditorDiv', STARTER_CODE, false);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('moveToWallCanvas');
    karelIde = KarelIde('python',karelEditor, canvas, '7x7', 0.0, 'fr');
    $('#moveToWallRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('moveToWallWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#moveToWallRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#moveToWallRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 316.8;
    var canvasWidth = 300
    var parentWidth = $("#moveToWall").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('moveToWallIde');
    var editorDiv = document.getElementById('moveToWallEditorDiv');
    var canvas = document.getElementById('moveToWallCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplemoveToWall();
    </script>
</div>

<p>Essayez de changer le monde en cliquant sur le menu déroulant "Changer le monde" au-dessus du monde. Pour n'importe quel monde de taille, Karel sera avancer jusqu'à ce qu'il touche un mur. Notez que cet exploit ne peut pas être accompli en utilisant un <code class="keyword">for</code>  boucle. Cela nous obligerait à connaître la taille du monde au moment de la programmation.
</p>
<h3>Boucle While normale</h3>
<p>À Karel, un <code class="keyword">while</code>  la boucle est utilisée pour répéter un corps de code<i>aussi longtemps que</i>une condition donnée tient. le <code>while</code> loop a la forme générale suivante:</p>
<p class="demoCode">
 <code><span class="keyword">while</span> </code> <i class="demoText">tester</i> <code>:</code> <br/>
<i class="demoText" style="margin-left:2em">déclarations à répéter</i><br/>
</p>
<p>Le flux de contrôle d'un <code>while</code> la boucle est la suivante. Lorsque le programme atteint un <code>while</code> boucle il commence à répéter un processus là où il est en premier<i>chèques</i> si le test réussit, et si oui<i>run s</i>le code dans le corps.</p>
Quand le programme<i>chèques</i> si le test réussit, il décide si le<i class="demoText">tester</i>est vrai pour l'état actuel du monde. Si tel est le cas, la boucle run le code dans le corps. Si le test échoue, la boucle est terminée et le programme avancer est avancer .
<p>Quand le programme<i>run s</i>le corps de la boucle, le programme exécute les lignes du corps une par une. Lorsque le programme arrive à la fin du <code>while</code> boucle, il revient en haut de la boucle. Il revérifie ensuite le test, en continuant à boucler s'il réussit. Le programme ne quitte pas la boucle jusqu'à ce qu'il atteigne un contrôle, et le test échoue.</p>
<p>Karel a beaucoup<i class="demoText">tester</i> déclarations, et nous les passerons toutes en revue dans le chapitre suivant. Pour l'instant, nous allons utiliser une seule déclaration de test: <code>l'avant_est_clair()</code> ce qui est vrai s'il n'y a pas de mur directement devant Karel.</p>
<h3>Bug de poteau de clôture</h3>
<p>Modifions notre programme ci-dessus pour le rendre plus intéressant. Au lieu de simplement se déplacer vers un mur, jetons Karel de placer une ligne de jetons , une dans chaque case. Encore une fois, nous voulons que ce programme fonctionne pour un monde de toute taille:</p>





<div class="section embeddedIde" id="beeperLineBug1">
<div class="ide getStarted" id="beeperLineBug1Ide" style="height:299.20000000000005px">
<div class="ideCenter" id="beeperLineBug1IdeCenter">
<div class="ideEditorDiv" id="beeperLineBug1EditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineBug1CanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Changer le monde<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineBug1Worlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineBug1Canvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineBug1RunButton"><span class="glyphicon glyphicon-play"></span>Exécuter de programme</button>
</div>
</div>
<script>

        

function examplebeeperLineBug1() {
STARTER_CODE = `

# Fichier: Jeton LineBug.py
# ------------------------------
# Utilise un boucle while pour placer une ligne de jetons .
# Ce programme fonctionne pour un monde de toute taille.
# Cependant, parce que chaque monde en nécessite un de moins
# avancer s que put_ jetons il manque toujours un jeton .
from karel.stanfordkarel import *

# programme commence à main
def main():
   # se répète jusqu'à ce que Karel fasse face à un mur
   while l'avant_est_clair():
      # place un jeton sur la case actuelle
      laisser_jeton()
      # avancer au carré suivant
      avancer()


`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importPythonEditor('beeperLineBug1Editor','beeperLineBug1EditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineBug1Canvas');
    karelIde = KarelIde('python',karelEditor, canvas, '7x7', 0.0, 'fr');
    $('#beeperLineBug1RunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineBug1Worlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineBug1RunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineBug1RunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 299.20000000000005;
    var canvasWidth = 300
    var parentWidth = $("#beeperLineBug1").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineBug1Ide');
    var editorDiv = document.getElementById('beeperLineBug1EditorDiv');
    var canvas = document.getElementById('beeperLineBug1CanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLineBug1();
    </script>
</div>

<p>Ça a l'air génial. Sauf pour un problème. Sur tous les jeton Karel ne place pas de jeton sur le dernier carré de la ligne (regardez bien). Lorsque Karel est sur le dernier carré, le programme n'exécute pas le corps de la boucle car le test ne passe plus - Karel est face à un mur. Vous pourriez être tenté d'essayer de changer l'ordre du corps afin que Karel avancer s avant de placer un jeton . Le code est modifiable alors essayez-le!</p>
<p>Il y a un problème plus profond qu'aucun réarrangement du corps ne peut résoudre. Pour le monde à 7 colonnes, Karel doit mettre 7 jetons , mais ne devrait <code>avancer()</code> 6 fois. Depuis le <code>while</code> loop exécute les deux lignes lorsqu'un test réussit, comment pouvez-vous faire en sorte que le programme exécute une commande une fois de plus que l'autre?</p>
<p>Le bogue de ce programme est un exemple de problème de programmation appelé <b>erreur de poteau de clôture</b> . Le nom vient du fait que si vous voulez construire une clôture faite de panneaux qui ont un poteau de clôture sur l'une ou l'autre taille, le nombre de poteaux de clôture est toujours supérieur au nombre de panneaux. De combien de poteaux de clôture, par exemple, avez-vous besoin pour construire une clôture avec 10 panneaux? La réponse est 11, comme l'illustre le diagramme suivant:</p>
<center>
<img src="//compedu.stanford.edu/codeinternational/docsimages/ch6/fencepost.png" style="width:500px;margin-bottom:10px"/> 
</center>
<p>Une fois que vous l'avez découvert, corriger ce bogue est en fait assez facile. Avant que Karel ne s'arrête au bout du monde, tout ce que le programme a à faire est de placer un dernier jeton :</p>





<div class="section embeddedIde" id="beeperLine">
<div class="ide getStarted" id="beeperLineIde" style="height:334.40000000000003px">
<div class="ideCenter" id="beeperLineIdeCenter">
<div class="ideEditorDiv" id="beeperLineEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Changer le monde<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineWorlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineRunButton"><span class="glyphicon glyphicon-play"></span>Exécuter de programme</button>
</div>
</div>
<script>

        

function examplebeeperLine() {
STARTER_CODE = `


# Fichier: JetonLigne.py
# ------------------------------
# Utilise un boucle while pour placer une ligne de jetons .
# Ce programme fonctionne pour un monde de toute taille.
from karel.stanfordkarel import *

# programme commence à main
def main():
   # se répète jusqu'à ce que Karel fasse face à un mur
   while l'avant_est_clair():
      # place un jeton sur la case actuelle
      laisser_jeton()
      # avancer au carré suivant
      avancer()
   # résout le bogue de clôture
   laisser_jeton()



`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importPythonEditor('beeperLineEditor','beeperLineEditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineCanvas');
    karelIde = KarelIde('python',karelEditor, canvas, '7x7', 0.8, 'fr');
    $('#beeperLineRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 334.40000000000003;
    var canvasWidth = 300
    var parentWidth = $("#beeperLine").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineIde');
    var editorDiv = document.getElementById('beeperLineEditorDiv');
    var canvas = document.getElementById('beeperLineCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLine();
    </script>
</div>
<hr/>
<center>
<a class="btn btn-primary btn-lg" href="chapter7.html" role="button">Chapitre suivant</a> 
</center>




<div style="height:60px"></div>
</div>
</div>
</div>
<!-- right gutter -->
<div style="flex-grow:4"></div>
</div>
</div>
</body>
</html>
